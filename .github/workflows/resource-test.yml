name: Resource Testing

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  test-multiple-resources:
    name: Test Multiple Resources (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup MSVC (Windows only)
      if: runner.os == 'Windows'
      uses: ilammy/msvc-dev-cmd@v1
      
    - name: Install dependencies (Linux)
      if: runner.os == 'Linux'
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential cmake nasm
        
    - name: Install NASM (official, Windows)
      if: runner.os == 'Windows'
      run: |
        $url = "https://www.nasm.us/pub/nasm/releasebuilds/2.16.03/win64/nasm-2.16.03-win64.zip"
        $out = "$env:RUNNER_TEMP\nasm.zip"
        Invoke-WebRequest $url -OutFile $out
        Expand-Archive $out -DestinationPath "C:\nasm"
        $nasmDir = Get-ChildItem "C:\nasm" | Where-Object { $_.PSIsContainer } | Select-Object -First 1 -ExpandProperty FullName
        echo "Добавляю $nasmDir в PATH"
        echo "$nasmDir" | Out-File -FilePath $env:GITHUB_PATH -Append
        Get-ChildItem "$nasmDir"
      shell: pwsh

    - name: Show NASM version (Windows)
      if: runner.os == 'Windows'
      run: nasm.exe -v
      shell: pwsh
        
    - name: Show versions
      run: |
        echo "=== System Information ==="
        echo "OS: ${{ matrix.os }}"
        echo ""
        echo "=== CMake Version ==="
        cmake --version
        echo ""
        if [ "${{ runner.os }}" = "Linux" ]; then
          echo "=== GCC Version ==="
          gcc --version
          echo ""
          echo "=== NASM Version ==="
          nasm -v
        elif [ "${{ runner.os }}" = "Windows" ]; then
          echo "=== MSVC Version ==="
          cl 2>&1 | findstr "Microsoft" || true
          echo ""
          echo "=== NASM Version ==="
          nasm -v
        fi
      shell: bash
        
    - name: Create test resources (Unix)
      if: runner.os != 'Windows'
      run: |
        mkdir -p test_resources
        echo "Test resource 1" > test_resources/resource1.txt
        echo "Test resource 2 with different content!" > test_resources/resource2.txt
        printf "Binary data: \x00\x01\x02\x03\xFF" > test_resources/binary.dat
      shell: bash
        
    - name: Create test resources (Windows)
      if: runner.os == 'Windows'
      run: |
        New-Item -ItemType Directory -Path "test_resources" -Force
        "Test resource 1" | Out-File -FilePath "test_resources/resource1.txt" -Encoding UTF8
        "Test resource 2 with different content!" | Out-File -FilePath "test_resources/resource2.txt" -Encoding UTF8
        [byte[]]$binaryData = 0x00, 0x01, 0x02, 0x03, 0xFF
        [System.IO.File]::WriteAllBytes("test_resources/binary.dat", $binaryData)
      shell: pwsh
        
    - name: Create test application (Unix)
      if: runner.os != 'Windows'
      run: |
        cat > test_app.cpp << 'EOF'
        #include "res_embed.h"
        #include <cstdio>
        #include <cstring>
        #include <iostream>
        
        int main() {
            // Test text resource 1
            const char* res1 = res::embed::get("resource1");
            if (strcmp(res1, "Test resource 1\n") != 0) {
                std::cerr << "Resource 1 mismatch" << std::endl;
                return 1;
            }
            
            // Test text resource 2
            const char* res2 = res::embed::get("resource2");
            if (strcmp(res2, "Test resource 2 with different content!\n") != 0) {
                std::cerr << "Resource 2 mismatch" << std::endl;
                return 1;
            }
            
            // Test binary resource
            const char* binary = res::embed::get("binary");
            size_t binary_size = res::embed::size("binary");
            if (binary_size != 5) {
                std::cerr << "Binary resource size mismatch: expected 5, got " << binary_size << std::endl;
                return 1;
            }
            
            // Check binary content
            unsigned char expected[] = {0x00, 0x01, 0x02, 0x03, 0xFF};
            for (size_t i = 0; i < 5; i++) {
                if ((unsigned char)binary[i] != expected[i]) {
                    std::cerr << "Binary data mismatch at byte " << i << std::endl;
                    return 1;
                }
            }
            
            std::cout << "All resource tests passed!" << std::endl;
            return 0;
        }
        EOF
      shell: bash
        
    - name: Create test application (Windows)
      if: runner.os == 'Windows'
      run: |
        @'
        #include "res_embed.h"
        #include <cstdio>
        #include <cstring>
        #include <iostream>
        
        int main() {
            // Test text resource 1
            const char* res1 = res::embed::get("resource1");
            if (strcmp(res1, "Test resource 1\n") != 0) {
                std::cerr << "Resource 1 mismatch" << std::endl;
                return 1;
            }
            
            // Test text resource 2
            const char* res2 = res::embed::get("resource2");
            if (strcmp(res2, "Test resource 2 with different content!\n") != 0) {
                std::cerr << "Resource 2 mismatch" << std::endl;
                return 1;
            }
            
            // Test binary resource
            const char* binary = res::embed::get("binary");
            size_t binary_size = res::embed::size("binary");
            if (binary_size != 5) {
                std::cerr << "Binary resource size mismatch: expected 5, got " << binary_size << std::endl;
                return 1;
            }
            
            // Check binary content
            unsigned char expected[] = {0x00, 0x01, 0x02, 0x03, 0xFF};
            for (size_t i = 0; i < 5; i++) {
                if ((unsigned char)binary[i] != expected[i]) {
                    std::cerr << "Binary data mismatch at byte " << i << std::endl;
                    return 1;
                }
            }
            
            std::cout << "All resource tests passed!" << std::endl;
            return 0;
        }
        '@ | Out-File -FilePath "test_app.cpp" -Encoding UTF8
      shell: pwsh
        
    - name: Create CMakeLists.txt for test (Unix)
      if: runner.os != 'Windows'
      run: |
        cat > CMakeLists.txt << 'EOF'
        cmake_minimum_required(VERSION 3.17)
        project(resource_test LANGUAGES C CXX)
        
        # Add the res_embed subdirectory
        add_subdirectory(. res_embed_build)
        
        # Create test executable
        add_executable(resource_test test_app.cpp)
        
        # Embed multiple resources
        res_embed(TARGET resource_test NAME "resource1" PATH ${CMAKE_CURRENT_SOURCE_DIR}/test_resources/resource1.txt)
        res_embed(TARGET resource_test NAME "resource2" PATH ${CMAKE_CURRENT_SOURCE_DIR}/test_resources/resource2.txt)
        res_embed(TARGET resource_test NAME "binary" PATH ${CMAKE_CURRENT_SOURCE_DIR}/test_resources/binary.dat)
        EOF
      shell: bash
        
    - name: Create CMakeLists.txt for test (Windows)
      if: runner.os == 'Windows'
      run: |
        @'
        cmake_minimum_required(VERSION 3.17)
        project(resource_test LANGUAGES ASM C CXX)
        
        # Add the res_embed subdirectory
        add_subdirectory(. res_embed_build)
        
        # Create test executable
        add_executable(resource_test test_app.cpp)
        
        # Embed multiple resources
        res_embed(TARGET resource_test NAME "resource1" PATH ${CMAKE_CURRENT_SOURCE_DIR}/test_resources/resource1.txt)
        res_embed(TARGET resource_test NAME "resource2" PATH ${CMAKE_CURRENT_SOURCE_DIR}/test_resources/resource2.txt)
        res_embed(TARGET resource_test NAME "binary" PATH ${CMAKE_CURRENT_SOURCE_DIR}/test_resources/binary.dat)
        '@ | Out-File -FilePath "CMakeLists.txt" -Encoding UTF8
      shell: pwsh
        
    - name: Configure CMake
      run: |
        cmake -B build -DCMAKE_BUILD_TYPE=Release
        
    - name: Build
      run: |
        cmake --build build --config Release
        
    - name: Run test (Unix)
      if: runner.os != 'Windows'
      run: |
        cd build
        ./resource_test
        
    - name: Run test (Windows)
      if: runner.os == 'Windows'
      run: |
        cd build/Release
        ./resource_test.exe
